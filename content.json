{"meta":{"title":"WY的个人博客","subtitle":"","description":"","author":"WY","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"变量提升与函数提升","slug":"js-变量提升","date":"2021-10-15T02:24:27.000Z","updated":"2021-10-15T02:48:10.572Z","comments":true,"path":"2021/10/15/js-变量提升/","link":"","permalink":"http://example.com/2021/10/15/js-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"变量提升123a = 2;var a;console.log( a );//2 按道理应该输出为 undefined，但是，真正的输出结果是 2。 12console.log( a );//undefinedvar a = 2; 按道理应该抛出 ReferenceError 异常，但是，真正的输出结果是 undefined。 这两个问题是因为变量提升了。","text":"变量提升123a = 2;var a;console.log( a );//2 按道理应该输出为 undefined，但是，真正的输出结果是 2。 12console.log( a );//undefinedvar a = 2; 按道理应该抛出 ReferenceError 异常，但是，真正的输出结果是 undefined。 这两个问题是因为变量提升了。 为什么会产生变量提升因为在运行js代码时，引擎首先会对进行编译。 编译阶段中的有一部分工作就是找到所有的声明，用合适的作用域将它们联系起来。 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 上面的代码将会被编译成： 123var a;a = 2;console.log( a );//2 123var aconsole.log( a );//undefineda = 2; ES6中let和const是没有变量提升123a = 2;let a;console.log( a );//ReferenceError 函数提升函数提升与变量提升类似，但是一个值得注意的细节是函数会首先被提升，然后才是变量。 12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 函数声明会被提升，但是函数表达式却不会被提升。 1234foo(); // 不是 ReferenceError, 而是 TypeErrorvar foo = function bar() &#123; console.log( 2 );&#125;;","categories":[],"tags":[]},{"title":"11111","slug":"11111","date":"2021-10-15T01:24:27.000Z","updated":"2021-10-15T01:24:27.050Z","comments":true,"path":"2021/10/15/11111/","link":"","permalink":"http://example.com/2021/10/15/11111/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[],"tags":[]}